var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    }
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports", "./base64", "./syncable", "./types", "./uid"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var base64 = require("./base64");
    var syncable_1 = require("./syncable");
    var types_1 = require("./types");
    var uid = require("./uid");
    /**
     * Represents a single syncable document (top-level JSON object or array)
     * Keeps track of client state for this document across all the clients.
     * The Document is composed out of Syncable instances (wrappers around objects or arrays),
     * and primitive values. It can be nested arbitrarily deep, but all Syncables link back to the master Document.
     */
    var Document = /** @class */ (function (_super) {
        __extends(Document, _super);
        /**
         * Document class constructor
         * @param data Initial data for this instance, or a changes object (generated by getChanges)
         * @param restore If true, create this document as the client that generated the changes object
         * @constructor Document
         */
        function Document(data, restore) {
            var _this = this;
            if (typeof data !== "object")
                throw new Error("Argument must be an object");
            if (types_1.isArray(data))
                throw new Error("Argument cannot be an array");
            var isChanges = data && data._minisync && (data._minisync.dataType === "CHANGES" /* Changes */);
            if (isChanges && data.changesSince)
                throw new Error("change block must be non-delta");
            var shouldMerge = isChanges && !restore;
            var shouldRestore = isChanges && restore;
            _this = _super.call(this) || this;
            _this.setDocument(_this);
            if (shouldMerge) {
                // initialize as same document, but empty (before first version)
                _this.setData({ _s: {
                        id: data.documentID, u: null, t: null
                    } });
                // set the initial version
                _this.getDocVersion();
                // merge all the remote changes into our blank document
                _this.mergeChanges(data);
                // for all client states, mark last confirmed send as current version
                var clientStates = _this.getClientStates();
                for (var _i = 0, clientStates_1 = clientStates; _i < clientStates_1.length; _i++) {
                    var clientState = clientStates_1[_i];
                    clientState.lastAcknowledged = _this.getDocVersion();
                }
            }
            else if (shouldRestore) {
                _this.setData(data.changes, true);
                _this.setClientID(data.sentBy);
                _this.setDocVersion(data.fromVersion);
                _this.setClientStates(data.clientStates);
            }
            else { // first init from raw data
                _this.setData(data);
                // ensure an initial state exists
                _this.getDocVersion();
            }
            return _this;
        }
        /**
         * Return the unique client ID of the document on this machine
         * @return {string}
         */
        Document.prototype.getClientID = function () {
            var state = this.getState();
            if (!state.clientID)
                state.clientID = uid.nextLong();
            return state.clientID;
        };
        /**
         * Return the master version for this document (on this client)
         * @returns {string}
         */
        Document.prototype.getDocVersion = function () {
            var version = this.getState().v;
            if (!version)
                version = this.nextDocVersion();
            return version;
        };
        /**
         * Increment the document version and return it
         * @returns {string}
         */
        Document.prototype.nextDocVersion = function () {
            return this.getState().v =
                base64.nextVersion(this.getState().v, 10);
        };
        /**
         * Get the state object for a remote client
         * @param {String} clientID
         * @return {*} state object = {clientID, lastAcknowledged, lastReceived}
         */
        Document.prototype.getClientState = function (clientID) {
            var states = this.getClientStates();
            var clientData = states.find(function (s) { return s.clientID === clientID; });
            if (!clientData)
                states.push(clientData = {
                    clientID: clientID,
                    // local version last confirmed as received remotely
                    // we should send only newer versions than this
                    lastAcknowledged: null,
                    // remote version that was last received
                    // we can ignore older remote versions than this
                    lastReceived: null
                });
            return clientData;
        };
        /**
         * Return an array of the remote state objects for all known clients
         * @returns {Array}
         */
        Document.prototype.getClientStates = function () {
            var state = this.getState();
            if (!state.remote)
                state.remote = [];
            return state.remote;
        };
        /**
         * Get updates to send to a remote client
         * @param {String} [clientID] Unique ID string for the remote client to get a delta update.
         * Leave empty to generate a universal state object containing the whole document
         * that can be synchronized against any remote client (even if never synced before)
         * @returns {*} data object to send
         */
        Document.prototype.getChangesForClient = function (clientID) {
            var changesSince = null;
            if (clientID) {
                var clientState = this.getClientState(clientID);
                changesSince = clientState.lastAcknowledged;
            }
            return this.getChanges(changesSince);
        };
        /**
         * Get updates to send to a remote client
         * @param {String} [fromVersion] The version to generate a changes object from (for delta updates).
         * Leave empty to generate a universal state object containing the whole document
         * that can be synchronized against any remote client (even if never synced before)
         * @returns {*} data object to send
         */
        Document.prototype.getChanges = function (fromVersion) {
            if (fromVersion === void 0) { fromVersion = null; }
            return {
                _minisync: {
                    dataType: "CHANGES" /* Changes */,
                    version: 1
                },
                documentID: this.getID(),
                sentBy: this.getClientID(),
                fromVersion: this.getDocVersion(),
                clientStates: this.getClientStates(),
                changesSince: fromVersion,
                changes: this.getChangesSince(fromVersion)
            };
        };
        /**
         * Merge updates from a remote client, updating the data and P2P client state
         * @param data Change data
         * @returns {*} data object to send
         */
        Document.prototype.mergeChanges = function (data) {
            if (data) {
                if (data.documentID !== this.getID()) {
                    throw new Error("unable to merge changes from a different document");
                }
                // state of remote client as stored in this copy of the document
                var clientState = this.getClientState(data.sentBy);
                // state of this client as stored in the remote copy of the document
                var remoteState = null;
                for (var _i = 0, _a = data.clientStates; _i < _a.length; _i++) {
                    var clientState_1 = _a[_i];
                    if (clientState_1.clientID === this.getClientID()) {
                        remoteState = clientState_1;
                        break;
                    }
                }
                if (remoteState && (clientState.lastAcknowledged < remoteState.lastReceived)) {
                    clientState.lastAcknowledged = remoteState.lastReceived;
                }
                var allWasSent = clientState.lastAcknowledged === this.getDocVersion();
                // inherited, actual merging of changes
                _super.prototype.mergeChanges.call(this, data.changes, clientState);
                clientState.lastReceived = data.fromVersion;
                for (var _b = 0, _c = data.clientStates; _b < _c.length; _b++) {
                    remoteState = _c[_b];
                    if (remoteState.clientID !== this.getClientID()) {
                        var localState = this.getClientState(remoteState.clientID);
                        // update remote version that was last received
                        if (localState.lastReceived < remoteState.lastReceived) {
                            localState.lastReceived = remoteState.lastReceived;
                        }
                        // if our state matches the state of the other client
                        // and their state matches the state of the third party
                        // the third party has received our version already
                        if (allWasSent && (data.fromVersion === remoteState.lastAcknowledged)) {
                            localState.lastAcknowledged = this.getDocVersion();
                        }
                    }
                }
                // syncing updates the local version
                // we shouldn't send updates for versions added by syncing
                if (allWasSent) {
                    clientState.lastAcknowledged = this.getDocVersion();
                }
            }
            else {
                throw new Error("Invalid changes object");
            }
        };
        /**
         * Change the unique client ID of the document on this machine
         * @param {string} id
         */
        Document.prototype.setClientID = function (id) {
            this.getState().clientID = id;
        };
        /**
         * Set the version of this document to a different one
         * @param {string} v
         */
        Document.prototype.setDocVersion = function (v) {
            this.getState().v = v;
        };
        /**
         * Set a new array of remote client states
         * @param states
         */
        Document.prototype.setClientStates = function (states) {
            var state = this.getState();
            state.remote = states || [];
        };
        return Document;
    }(syncable_1.Syncable));
    exports.Document = Document;
});
//# sourceMappingURL=document.js.map