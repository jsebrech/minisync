import * as base64 from "./base64";
import {Syncable} from "./syncable";
import {ChangesObject, ClientID, ClientState, DocumentState,
        isArray, LatestUpdate, ObjectDataType, Peer, Version} from "./types";
import * as uid from "./uid";

/**
 * Represents a single syncable document (top-level JSON object or array).
 * Keeps track of client state for this document across all the clients.
 *
 * The Document is composed out of Syncable instances (wrappers around objects or arrays),
 * and primitive values. It can be nested arbitrarily deep, but all Syncables link back to the master Document.
 */
export class Document extends Syncable {

    /**
     * Document class constructor
     * @param data Initial data for this instance, or a changes object (generated by getChanges)
     * @param restore If true, create this document as the client that generated the changes object
     * @constructor Document
     */
    constructor(data: ChangesObject | any, restore?: boolean) {
        if (typeof data !== "object") throw new Error("Argument must be an object");
        if (isArray(data)) throw new Error("Argument cannot be an array");
        const isChanges: boolean =
            data && data._minisync && (data._minisync.dataType === ObjectDataType.Changes);
        if (isChanges && data.changesSince) throw new Error("change block must be non-delta");
        const shouldMerge: boolean = isChanges && !restore;
        const shouldRestore: boolean = isChanges && restore;
        super();
        this.setDocument(this);
        if (shouldMerge) {
            // initialize as same document, but empty (before first version)
            this.setData({ _s: {
                id: data.documentID, u: null, t: null
            }});
            // set the initial version
            this.getDocVersion();
            // merge all the remote changes into our blank document
            this.mergeChanges(data);
            // for all client states, mark last confirmed send as current version
            const clientStates: ClientState[] = this.getClientStates();
            for (const clientState of clientStates) {
                clientState.lastAcknowledged = this.getDocVersion();
            }
        } else if (shouldRestore) {
            this.setData(data.changes, true);
            this.setClientID(data.sentBy);
            this.setDocVersion(data.fromVersion);
            this.setClientStates(data.clientStates);
        } else { // first init from raw data
            this.setData(data);
            // ensure an initial state exists
            this.getDocVersion();
        }
    }

    /**
     * Return the unique client ID of the document on this machine
     * @return {string}
     */
    public getClientID(): ClientID {
        const state: DocumentState = this.getState();
        if (!state.clientID) state.clientID = uid.nextLong();
        return state.clientID;
    }

    /**
     * Returns the synchronization state of this document
     */
    public getState(): DocumentState {
        return super.getState() as DocumentState;
    }

    /**
     * Return the master version for this document (on this client)
     * @returns {string}
     */
    public getDocVersion(): Version {
        let version: Version = this.getState().v;
        if (!version) version = this.nextDocVersion();
        return version;
    }

    /**
     * Increment the document version and return it
     * @returns {string}
     */
    public nextDocVersion(): Version {
        return this.getState().v =
            base64.nextVersion(this.getState().v, 10);
    }

    /**
     * Get the state object for a remote client
     * @param {String} clientID
     * @return {*} state object = {clientID, lastAcknowledged, lastReceived}
     */
    public getClientState(clientID: ClientID): ClientState {
        const states: ClientState[] = this.getClientStates();
        let clientData: ClientState = states.find((s) => s.clientID === clientID);
        if (!clientData) states.push(clientData = {
            clientID,
            // local version last confirmed as received remotely
            // we should send only newer versions than this
            lastAcknowledged: null,
            // remote version that was last received
            // we can ignore older remote versions than this
            lastReceived: null
        });
        return clientData;
    }

    /**
     * Return an array of the remote state objects for all known clients
     * @returns {Array}
     */
    public getClientStates(): ClientState[] {
        const state: DocumentState = this.getState();
        if (!state.remote) state.remote = [];
        return state.remote;
    }

    /**
     * Return an array of known peers that we sync with
     */
    public getPeers(): Peer[] {
        const state: DocumentState = this.getState();
        if (!state.peers) state.peers = [];
        return state.peers;
    }

    /**
     * Add or update a peer in the list of peers
     * @param peer The new peer info
     */
    public addPeer(peer: Peer) {
        // clean up the data object (might be a master index)
        peer = { url: peer.url, latestUpdate: peer.latestUpdate, label: peer.label};
        const peers = this.getPeers();
        const index = peers.findIndex((item) => item.url === peer.url);
        if (index >= 0) {
            peers[index] = peer;
        } else {
            peers.push(peer);
        }
    }

    /**
     * Get updates to send to a remote client
     * @param {String} [clientID] Unique ID string for the remote client to get a delta update.
     * Leave empty to generate a universal state object containing the whole document
     * that can be synchronized against any remote client (even if never synced before)
     * @returns {*} data object to send
     */
    public getChangesForClient(clientID: ClientID): ChangesObject {
        let changesSince: string = null;
        if (clientID) {
            const clientState: ClientState = this.getClientState(clientID);
            changesSince = clientState.lastAcknowledged;
        }
        return this.getChanges(changesSince);
    }

    /**
     * Get updates to send to a remote client
     * @param {String} [fromVersion] The version to generate a changes object from (for delta updates).
     * Leave empty to generate a universal state object containing the whole document
     * that can be synchronized against any remote client (even if never synced before)
     * @returns {*} data object to send
     */
    public getChanges(fromVersion: Version = null): ChangesObject {
        return {
            _minisync: {
                dataType: ObjectDataType.Changes,
                version: 1
            },
            documentID: this.getID(),
            sentBy: this.getClientID(),
            fromVersion: this.getDocVersion(),
            clientStates: this.getClientStates(),
            changesSince: fromVersion,
            changes: this.getChangesSince(fromVersion)
        };
    }

    /**
     * Merge updates from a remote client, updating the data and P2P client state
     * @param data Change data
     * @returns {*} data object to send
     */
    public mergeChanges(data: ChangesObject | any): void {
        if (data as ChangesObject) {
            if (data.documentID !== this.getID()) {
                throw new Error("unable to merge changes from a different document");
            }
            // state of remote client as stored in this copy of the document
            const clientState: ClientState = this.getClientState(data.sentBy);
            // state of this client as stored in the remote copy of the document
            let remoteState: ClientState = null;
            for (const clientState of data.clientStates) {
                if (clientState.clientID === this.getClientID()) {
                    remoteState = clientState;
                    break;
                }
            }
            if (remoteState && (clientState.lastAcknowledged < remoteState.lastReceived)) {
                clientState.lastAcknowledged = remoteState.lastReceived;
            }
            const allWasSent: boolean = clientState.lastAcknowledged === this.getDocVersion();
            // inherited, actual merging of changes
            super.mergeChanges(data.changes, clientState);
            clientState.lastReceived = data.fromVersion;

            for (remoteState of data.clientStates) {
                if (remoteState.clientID !== this.getClientID()) {
                    const localState: ClientState = this.getClientState(remoteState.clientID);
                    // update remote version that was last received
                    if (localState.lastReceived < remoteState.lastReceived) {
                        localState.lastReceived = remoteState.lastReceived;
                    }
                    // if our state matches the state of the other client
                    // and their state matches the state of the third party
                    // the third party has received our version already
                    if (allWasSent && (data.fromVersion === remoteState.lastAcknowledged)) {
                        localState.lastAcknowledged = this.getDocVersion();
                    }
                }
            }

            // syncing updates the local version
            // we shouldn't send updates for versions added by syncing
            if (allWasSent) {
                clientState.lastAcknowledged = this.getDocVersion();
            }
        } else {
            throw new Error("Invalid changes object");
        }
    }

    /**
     * Is this document newer than the latest update of another client?
     * @param otherUpdate The other client's latest update
     */
    public isNewerThan(otherUpdate: LatestUpdate): boolean {
        // crossed wires, assume we're older
        if (!otherUpdate) return false;
        const clientState = this.getClientState(otherUpdate.clientID);
        // we've never received a version from them, so assume we're older
        if (!clientState.lastReceived) {
            return false;
        // we have received a version from them, compare against that
        } else {
            return clientState.lastReceived >= otherUpdate.version;
        }
    }

    /**
     * Change the unique client ID of the document on this machine
     * @param {string} id
     */
    private setClientID(id: ClientID): void {
        this.getState().clientID = id;
    }

    /**
     * Set the version of this document to a different one
     * @param {string} v
     */
    private setDocVersion(v: Version): void {
        this.getState().v = v;
    }

    /**
     * Set a new array of remote client states
     * @param states
     */
    private setClientStates(states: ClientState[]): void {
        const state: DocumentState = this.getState();
        state.remote = states || [];
    }

}
